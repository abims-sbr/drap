#!/usr/bin/perl
# $Id$

=pod

=head1 NAME

 submit

=head1 SYNOPSIS

 submit.pl CMD_FILE [--help]

=head1 DESCRIPTION

 Executes the command(s) described in a JSON file generated by CmdSet->TO_JSON.
 The execution is submitted locally or on HPC (see SchedulerFactory).
 
=head1 OPTIONS

=over 8

=item B<CMD_FILE>

The command set stored in JSON file (see CmdSet->TO_JSON())).

=item B<-h, --help>

Print help.

=back

=head1 VERSION

 1.0.0

=head1 AUTHOR

 Frédéric Escudié - Plateforme Bioinformatique de Toulouse
 (support.genopole@toulouse.inra.fr)

=head1 COPYRIGHT

 2015 INRA

=head1 LICENSE

 GNU GPLv3

=cut

use strict ;
use warnings ;
use JSON ;
use List::Util 'max' ;
use FindBin ;
use lib("$FindBin::Bin") ;
use CmdSet ;



=head2 function to_size_unit

 Usage        : $new_mem = to_size_unit( $mem, $new_unit )
 Function     : Changes the memory unit. 
                Example: to_size_unit("1Tb", "Gb") => "1024Gb"
 Return       : [str] The memory with the new unit.
 Args         : [str] The memory and the old unit.
                [str] The new unit.

=cut
sub to_size_unit {
	my ($mem, $new_unit) = @_ ;
	my $new_mem = undef ;
	
	if( $mem =~ /^(\d+)(\w+)$/ ){
		$new_mem = $1 ;
		my $unit = lc($2);
		my @unit_notation = ();
		if( length($unit) == 2 ){
			@unit_notation = ( "tb", "gb", "mb", "kb", "b" );
		} else {
			@unit_notation = ( "t", "g", "m", "k", "b" );
		}
		my $unit_rank = 0;
		++$unit_rank until $unit_notation[$unit_rank] eq lc($unit);
		my $new_unit_rank = 0 ;
		++$new_unit_rank until $unit_notation[$new_unit_rank] eq lc($new_unit);
		while( $unit_rank < $new_unit_rank ){
			$new_mem = 1024*$new_mem ;
			$unit_rank++ ;
		}
		while( $unit_rank > $new_unit_rank ){
			$new_mem = $new_mem/1024 ;
			$unit_rank-- ;
		}	
	} else {
		die "Error in size mangement" ;
	}
	
	return $new_mem ;
}


=head2 function max_mem

 Usage        : $max_mem = max_mem( $mem_a, $mem_b )
 Function     : Returns the largest memory.
 Return       : [str] The largest memory.
 Args         : [str] The first memory.
                [str] The second memory.

=cut
sub max_mem {
	my ($mem_a, $mem_b) = @_ ;

	if( to_size_unit($mem_a, "b") > to_size_unit($mem_b, "b") ){
		return $mem_a ;
	} else {
		return $mem_b ;	
	}
}


=head2 function get_local_ressources

 Usage        : @max_ressources = get_local_ressources( $cmd )
 Function     : Returns the largest resources used by the CmdSet or his 
                descendants.
 Return       : [array] The max memory, the max virtual memory and the max
                number of CPUs. 
 Args         : [Cmd/CmdSet] The command or command set to evaluate. 

=cut
sub get_local_ressources {
	my ($cmd) = @_ ;
	my $mem = "" ;
	my $virtual_mem = "" ;
	my $cpu = "" ;
	
	if( UNIVERSAL::isa($cmd, 'Cmd') ){
		$mem = $cmd->{mem} ;
		$virtual_mem = $cmd->{virtual_mem} ;
		$cpu = $cmd->{cpu} ;
	} else {
		foreach my $sub_cmd ( @{$cmd->{commands}} ){
			my $sub_mem = "" ;
			my $sub_virtual_mem = "" ;
			my $sub_cpu = "" ;
			# Get current sub command ressources
			if( UNIVERSAL::isa($sub_cmd, 'Cmd') ){
				$sub_mem = $sub_cmd->{mem} ;
				$sub_virtual_mem = $sub_cmd->{virtual_mem} ;
				$sub_cpu = $sub_cmd->{cpu} ;
			} elsif( UNIVERSAL::isa($sub_cmd->{scheduler}, 'LocalScheduler') ){
				($sub_mem, $sub_virtual_mem, $sub_cpu) = get_local_ressources( $sub_cmd );
			}
			# Select the most important ressource
			if( $mem eq "" ){
				$mem = $sub_mem ;
			} elsif( $sub_mem ne "" ){
				$mem = max_mem( $mem, $sub_mem );
			}
			if( $virtual_mem eq "" ){
				$virtual_mem = $sub_virtual_mem ;
			} elsif( $sub_virtual_mem ne "" ){
				$virtual_mem = max_mem( $virtual_mem, $sub_virtual_mem );
			}
			if( $cpu eq "" ){
				$cpu = $sub_cpu ;
			} elsif( $sub_cpu ne "" ){
				$cpu = max( $cpu, $sub_cpu );
			}
		}
	}
	
	return $mem, $virtual_mem, $cpu ;
}

=head2 function load_json

 Usage        : $hash = load_json( $path )
 Function     : Returns the hash representation of the json.
 Return       : [str] The reference to the hash representation of the json
                content.
 Args         : [str] The json path.

=cut
sub load_json {
	my ($path) = @_ ;

	# Load data
	local $/ = undef ;
	open( my $FH_json, '<', $path ) or die "Unable to open '".$path."'" ;
	my $json_text = <$FH_json> ;
	close( $FH_json );

	return from_json( $json_text, { utf8  => 1 } );
}


MAIN:
{
	my $workflow_path = $ARGV[0] ;
	my $workflow_cmd_set = new CmdSet();
	$workflow_cmd_set->from_hash( load_json($workflow_path) );
	
	# Extract sub CommandSet
	for( my $cmd_idx = 0 ; $cmd_idx < @{$$workflow_cmd_set{commands}} ; $cmd_idx++ ){
		my $cmd = $$workflow_cmd_set{commands}[$cmd_idx] ;

		if( UNIVERSAL::isa($cmd, 'CmdSet') ){
			my $sub_commands_set_path = $workflow_path."_subCmd_".$cmd_idx.".json" ;
			
			# Write sub_step json
			open( my $SUB_JSON_FH, ">", $sub_commands_set_path ) or die "Can't create file ".$sub_commands_set_path."\n" ;
			print $SUB_JSON_FH JSON->new->utf8->allow_nonref->pretty->convert_blessed->encode($cmd) ;
			close( $SUB_JSON_FH );
			
			# Manage local ressources
			my $mem = undef ;
			my $virtual_mem = undef ;
			my $cpu = undef ;
			if( UNIVERSAL::isa($cmd->{scheduler}, 'LocalScheduler') ){
				($mem, $virtual_mem, $cpu) = get_local_ressources( $cmd );
			}
			
			# Replace command set by script
			my $new_cmd = new Cmd( "perl ".$0." ".$sub_commands_set_path, $cpu, $mem, $virtual_mem );
			$$workflow_cmd_set{commands}[$cmd_idx] = $new_cmd ;
		}
	}
	
	# Execute workflow
	$workflow_cmd_set->submit() ;
	
	# Remove sub_steps json
	for( my $cmd_idx = 0 ; $cmd_idx < @{$$workflow_cmd_set{commands}} ; $cmd_idx++ ){
		my $sub_commands_set_path = $workflow_path."_subCmd_".$cmd_idx.".json" ;
		if( $$workflow_cmd_set{commands}[$cmd_idx]->{"cmd"} eq "perl ".$0." ".$sub_commands_set_path ){
			unlink( $sub_commands_set_path );
		}
	}
}